\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath, amsthm, verbatim, enumerate, xcolor, mathpartir}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{syntax}

\input{macros}

\title{Verifying a Postfix Language \\
    \large CS595 Final Project}
\author{Dustin Van Tate Testa and Andrew Neth}

\begin{document}
\maketitle
\begin{abstract}
A formalization and some proofs of soundness is given to a subset of \href{https://github.com/dvtate/postfix-haskell}{a functional, postfix language}.
\end{abstract}

\section{Introduction}
\subsection{Motivation}
WebAssembly is a typed, stack-machine based assembly language which is widely supported across all major browsers. A number of new languages have come about with the goal of providing better support for the platform. Additionally it has proven the utility of typed stack-machines as a reasonably safe way to write programs.

There appears to be little research into stack-based, functional languages (likely due to these languages not being common), thus more exploration on the topic could likely produce some value.

\href{https://github.com/dvtate/postfix-haskell}{The language this paper focuses on} is currently being used to power \href{https://ridder.xyz/game}{some insignificant demos}, but maybe in some distant future it will end up as the backend for a visual programming tool or some other application where guarantees of safety which could be produced here would be very important.

\subsection{The Language}
This section describes some of the key features of the original language. It is included only to show that the subset is a good representation of the original language and thus can be skipped.

\subsubsection{Syntax}
\begin{itemize}
    \item \textbf{Primitive Literals:} The language supports numeric and string literals although in the paper we will likely only cover numbers.

    \item \textbf{Closures:} closures aka macros are enclosed within \texttt{(: ... )} and can have type annotations, for example \texttt{((I32 I32) (I32) rec: ... )}.

    \item \textbf{Tuples:} Tuples are enclosed within parenthesis. There is no reason to include separators like commas.

    \item \textbf{Identifiers:} there are two types of identifiers, escaped identifiers which start with \texttt{\$} are generally used for assignment and unescaped identifiers which are used for to invoke the value to which the identifier refers.
    
    In the language, identifiers can reference both typed and untyped values, but likely will be limited to typed values in the paper.

    \item \textbf{Functions:} function overloading is the only supported form of branching in the language. The syntax for the \texttt{fun} operator is as follows. 

    \texttt{(($..._1$)($..._2$ I32): Condition ) (: Action ) \$Identifier fun}.

    In the final paper this will likely get replaced with a ternary.

    \item \textbf{Other Operators:} Although the majority of primitive operators are defined in the standard library, the compiler actually has a few builtins as well. Although these are very important to actually using the language they aren't worthy of listing out in their entirety here. Some examples include: \texttt{require}, \texttt{use}, \texttt{import}, \texttt{export}, \texttt{asm}, \texttt{namespace}, \texttt{type}, \texttt{unpack}, \texttt{class}, \texttt{=}, \texttt{|}, \texttt{@}, \texttt{\~}, \texttt{==}, \texttt{make}
\end{itemize}
    
    Combining these concepts we can make the following program.
    
    \begin{verbatim}
    # Import basic math and logic
    "stdlib/prelude.phs" require use

    # Define a recursive factorial closure
    ((I32)(I32) rec:
        $n =
        (: 1 ) (: 1 ) $branch fun
        (: n 1 > ) (: n 1 - fac n * ) $branch fun
        branch
    ) $fac =
    
    # Export factorial to the host environment
    (I32) (: fac ) "factorial" export
    \end{verbatim}
    
    
\subsubsection{Type System}
The language currently features an incomplete type system (with some compile-time-only values not fitting into the type system). However for the paper we will simplify it to exclude these values (notably namespaces, string literals, etc.) as they don't do anything interesting.

\begin{itemize}
    \item \textbf{Primitives:} Types supported by WebAssembly: \texttt{I32 I64 F32 F64}
    \item \textbf{Tuples:} Types which represent the concept of adjacent values on the stack. And thus actually represent multiple values when compiled.
    \begin{itemize}
        \item \textbf{Relevant operators:} \texttt{pack unpack}.
        \item \textbf{Example:} \texttt{(F32 F32 F32) \$FloatVec3 =}.
    \end{itemize}

    \item \textbf{Unions:} Created using the \texttt{|} operator, either of it's two operands can satisfy it. At present, all union types must be resolved at compile time (ie - unions can exist as types but not values), but this should be resolved once the garbage collector is finished.

    \item \textbf{Unit \& Void}: \texttt{Unit} is the type of the empty tuple and \texttt{Void} does not typecheck.

    \item \textbf{\texttt{Any}}: matches with any given type/value. Useful for pattern matching.

    \item \textbf{\texttt{Arrow} Types}: the \texttt{Arrow} operator is used for macro types. 
    Example: \texttt{(F32 F32) (F32) Arrow \$BinaryOperator =}

    \item \textbf{Classes:} A similar concept in other languages would likely be 'traits', adding a class to a type gives it functionality designated by that class. Thus we can define \texttt{I32 class \$Color =} and then use bitwise operators in order to make the \texttt{Color} class represent a 32bit packed RGBA value. In addition to there are a number of more advanced ways to use the class

    \begin{itemize}
        \item \textbf{Instantiating:} the \texttt{make} operator is used to add a class to a value. So for the RGBA class we can do \texttt{0xff00ff80 Color make \$half\_magenta =}

        \item \textbf{Subclasses:} We can make a class of our color class to add new functionality, for example \texttt{Color class \$RenderEngineColor =}

        \item \textbf{Parametric Classes:} In addition to taking types as arguments, the class operator can take a macro, this allows one to describe more complex types. One such usage is to define type operators.

        \texttt{(: \$T = (T T T) ) class \$Vec3 =}\\
        \texttt{(1 2 3) I32 Vec3 make \$pos =}

        Note that here \texttt{class} is technically optional and the following would be the same but less strict.

        \texttt{(: \$T = (T T T) ) \$Vec3 =}\\
        \texttt{(1 2 3) \$pos =}\\
        so that \texttt{pos type I32 Vec3 == :data} gives 1

        In the paper we will avoid ambiguity likely take the approach of adding 'type macros' with a brackets syntax instead.

        \item \textbf{Recursive Classes:} By marking the macro in the class as recursive it's only accessed as a reference to an object stored on the heap. This allows the programmer to define recursive types. Will be added once GC is stable.

        \texttt{(rec: \$T = (T List T) Unit | ) class \$List =}\\
        \texttt{( 1 ( 2 () I32 List make ) I32 List make ) I32 List make}
    \end{itemize}
\end{itemize}

\section{Syntax}
Here some operations also include their stack arguments, this is intended only for clarity as to what their function is as their arguments are come from the stack when it's their turn to be evaluated, not syntactically.

\renewcommand{\grammarlabel}[2]{#1 \hfill#2}
\begin{grammar}
    <$\tau$> ::= $\kwInt$
    |    $\kwLong$
    |    $\kwFloat$
    |    $\kwDouble$
    |    $(\tau^*)$
    |    $\kwUnit$
    % |    $\tau_1~ \tau_2~ \texttt{|}$
    |    $\kwArrow{\tau_1} {\tau_2}$
    \alt $\kwType{e}$
    |    $e~ \kweid{T} =$
    |    $\kwid{T}$
    |    $\kwunpack{\tau}$

    <$e$> ::= $e~ e~ +$
    |    $e~ e~ \times$
    |    $\kwtern{e}{e}{e} $
    |    $e~ e~ ==$
    |    $\tau~ \tau~ ==$
    \alt $(e^*)$
    |    $\kwmacro{\tau^*}{e^*}$
    |    $\kwfix{e}{\tau}$
    |    $\kwnumlit{n}{\kwInt}$
    |    $\kwnumlit{n}{\kwLong}$
    |    $\kwnumlit{n}{\kwFloat}$
    |    $\kwnumlit{n}{\kwDouble}$
    \alt $e~ \kweid{x} =$
    |    $\kwid{x}$
    |    $e~ \textbf{@} $
    |    $\kwunpack{e}$
    
    <$prog$> ::= $e^*$ | $\tau^*$ | $prog~ prog$ | $\varepsilon$
\end{grammar}
Where $\varepsilon$ is used to denote an empty program/expression

\subsection{Included}

\subsection{Number Literals}
Number literals are denoted with subscript indicating the numeric type they correspond with.
This mirrors the actual language which uses the C-style syntax for number literal type inference.

\subsubsection{Branching}
As mentioned before a ternary operator would be a reasonable subset of branching via function overloading. The tern operator is defined as an operator which 

\begin{verbatim}
# Tern takes an I32 and two values of the same type
# and gives one of those two values
$tern ~ :type # :type - (I32 $A $A) ($A) Arrow

# As it is a subset we can define it in terms of functions
((I32 Any Any): type swap type == ) (: ( $c $a $b ) = b ) $tern fun
((I32 Any Any): type swap type == && ) (: ( $c $a $b ) = a ) $tern fun
\end{verbatim}

\subsubsection{Identifiers}
Identifiers are included, however, it was found that the notation for 
dereferencing an identifier $\kweid{x}~\texttt{~}$ was confusing and
thus the behavior was changed and thus the default behavior was
changed such that unescaped identifiers are dereferenced instead of 
called and values must be explicitly called via the $\texttt{@}$
operator.

\subsubsection{Macros}
Macros use a specific instance of the type annotations, notably where the
input types are specified and the output types are inferred. In order to 
enable recursion, a syntactic fixed-point combinator was provided to replace
the $\texttt{rec}$ syntax.

\subsubsection{Identical to base language}
\begin{enumerate}
    \item Tuples and tuple related operators
    \item type operator
    \item $\texttt{Arrow}$ type
    \item some math and comparison operators
\end{enumerate}

\subsection{Not included}
Things which were either out of scope, problematic, or uninteresting were unincluded. Here a re some of the notable ones.

\subsubsection{Classes}
As much as we would like to include classes (notably recursive classes), it 
would likely add excess complexity, requiring subtyping (on N dimensions); 
untyped closures which can operate on types; and likely some other painpoints.
And it's not clear how they could make the system unsafe as apart from being
used to define recursive types are simply specialized versions of preexisting
types.

\subsubsection{Functions}
Really the only reason the function overloading system was preferred instead
of normal branching in the original language was in order to make it easier 
to extend the language. Function overloading seems like it would be needlessly
painful to formalize and doesn't contribute to our proof of soundness any more
than branching via a ternary. As the case for functions having potentially no
possible branch results in a type error in the complete language and this is
simplified by having an else clause.

\subsubsection{Unions}
Although the language currently supports some operations with union types,
the system does not work at runtime when the true type is not known, thus,
a flaw in the base language was discovered while working on the semantics
for this subset and thus the original system needs to be redesigned. This
would likely mean that the only way to make runtime union-types would be
via the \texttt{make} operator which is related to \texttt{class} and we
would additionally need to either make a different way to branch on unions
or make the compiler able to determine if the condition implies a particular
union member. Additionally Void was not included as on paper, it doesn't
work with the type inference algorithm.

\begin{verbatim}
(()(I32 F32): ... ) $get_num =
get_num $n =
(: n type I32 == ) (: 
    # How do we know that it's an i32 here?
) $branch fun
(: n type F32 == ) (: 
    # How do we know that it's an f32 here?
) $branch fun
branch
\end{verbatim}

The above example program illustrates the problem with the language.

\section{Small Step Semantics For Values}
\subsection{Notation}
To annotate stack values we used the notation of two values being written next to each other, as they would be written in the language itself. The values at the bottom of the stack (furthest to the left) are often irrelevant, and thus can be omitted with this notation. The superscript * notation (ie - $e^*$) is used to annotate 0 or more of the preceding. This is explicitly defined in the syntax but implicitly expanded in the semantics.

\subsection{Value and Step Judgement}
The step judgement states that expressions are evaluated from left to right until everything is a value. Values are defined further as we go through.
{
    \centering
    \def \MathparLineskip {\lineskip=0.43cm}
    \begin{mathpar}
        % Derivation of e* -> e*'
        \Rule{STEP}
            {e_1 \step e_1'
                \\v_i \val ~ \forall~ v_i \in v^*}
            {v^* ~ e_1 ~ ... ~ e_n \step v^* ~ e_1' ~ ... ~ e_n}
        \and

        % number literals
        \Rule{V-1}
             {\forall ~ \tau \in \{ \kwInt, \kwLong, \kwFloat, \kwDouble\}}
             {\kwnumlit{n}{\tau} \val}
        \and
        
        % Tuple literals evaluation
        \Rule{TUPLES-1}
            {e^* \step e^{*\prime}}
            {( e^* ) \step ( e^{*\prime} )}
        \Rule{TUPLES-2}
            {v_i \val ~ \forall v_i \in v^*}
            {(v^*) \val}
        \and
    \end{mathpar}  
}

\subsection{Macros, Identifiers and Scoping}
The store, $\sigma$, consists of a list of \textit{scopes}, where each scope is a mapping from identifiers to values. Notice the addition of an auxiliary $\kw{end\_scope}$ operator which removes the current scope. A macro literal steps to a macro value by first stepping its input types until they're all values before substituting all of the values in the store within its body (forming a closure). Calling a macro value pushes a new empty mappings list onto the store, then places the macro's expressions and an $\kw{end\_scope}$ operator onto the stack, enabling local identifiers.
{
    \centering
    \def \MathparLineskip {\lineskip=0.43cm}
    \begin{mathpar}    
        % Closures capture lexically scoped variables via substitution 
        \Rule{LET}
            {v \val
                \\ \sigma = [ [...], ... [ x_1 \step v_1 ~...~ x_n \step v_n] ]
                \\ \sigma' = [ [...], ... [ x_1 \step v_1 ~...~ x_n \step v_n, x_{n+1} \step v] ]}
            {\sigma; v ~ \kweid{x} = \step \sigma'; \varepsilon}
            
        \and \Rule{Identifier}
            { \kwid{x} \step v \in \sigma(-1)}
            {\sigma; \kwid{x} \step \sigma; v}

        \and \Rule{CALL-1}
            {\sigma' = \sigma \cup [~]
                \\ v = \kwmacro{\tau^*}{e^*}
                \\ v \val}
            {\sigma; v~ \textbf{@} \step \sigma'; e^* \kw{end\_scope}}

        \and \Rule{CALL-2}
            {\sigma = [s_1,...s_n,s_{n+1}] \\ \sigma' = [s_1,...s_n]}
            {\sigma; \kw{end\_scope} \step \sigma'; \varepsilon}

    \end{mathpar}  
}

\subsection{Others}
Notice the use of the \href{https://en.wikipedia.org/wiki/Kronecker_delta}{Kronecker Delta} to define the equals operator.
{
    \centering
    \def \MathparLineskip {\lineskip=0.43cm}
    \begin{mathpar}
        % unpack operator
        \Rule{TUPLES-3}
            {v_i \val ~\forall~ v_i \in v^*}
            {\kwunpack{(v^*)} \step v^*}

        % math
        \Rule{ADD}
            {v_1 \val \\ v_2 \val \\ v_3 = v_1 + v_2}
            {v_1~ v_2~ + \step v_3}
        \and
        \Rule{MUL}
            {v_1 \val \\ v_2 \val \\ v_3 = v_1 * v_2}
            {v_1~ v_2~ \times \step v_3}
        \and
        
        % Comparisons
        \Rule{EQUIV}
            {v_1 \val \\ v_2 \val}
            {v_1~ v_2~ ==~ \step \kwnumlit{(\delta_{v_1 v_2})}{\kwInt}}

        % Ternary
        \Rule{TERN-1}
            {v_1 \val \\ v_2 \val}
            {\kwtern{\kwnumlit{0}{\kwInt}}{v_1}{v_2} \step v_2}
        \Rule{TERN-2}
            {v_1 \val \\ v_2 \val \\ n \neq 0}
            {\kwtern{\kwnumlit{n}{\kwInt}}{v_1}{v_2} \step v_1}
        \and
    \end{mathpar}
}

\section{Small Step Semantics for Types}
Because there are operations involving types, we have to have a equivalents to $\val$ and $\step$ judgements for types. These are provided by $\prim$ and $\tstep$ respectively.

\subsection{Primitives}
{
    \centering
    \def \MathparLineskip {\lineskip=0.43cm}
    \begin{mathpar}
        \Rule{P-I32}{\strut}{\kwInt \prim} \and
        \Rule{P-I64}{\strut}{\kwLong \prim} \and
        \Rule{P-F32}{\strut}{\kwFloat \prim} \and
        \Rule{P-F64}{\strut}{\kwDouble \prim} \and
        %\Rule{P-sum}{\tau_1 \prim \\ \tau_2 \prim}{\tau_1 \tau_2 \texttt{|} \prim} \and
        \Rule{P-Arrow}{\tau_1 \prim \\ \tau_2 \prim}{\kwArrow{\tau_1}{\tau_2} \prim} \and
    \end{mathpar}  
}

\subsection{Step Judgement}
Type expressions are evaluated left to right until everything is $\prim$. Types and expressions have equal precedence and both can be present on the stack.
{
    \centering
    \def \MathparLineskip {\lineskip=0.43cm}
    \begin{mathpar}
        % Derivation of T* -> T*'
        \Rule{TSTEP}
            {\tau \tstep \tau'
                \\\tau_i \prim ~ \forall~ \tau_i \in \tau_1^*}
            {\tau_1^* ~ \tau ~ \tau_2^* \tstep \tau_1^* ~ \tau' ~ \tau_2^*}

        \and \Rule{TSTEP - Mixed}
            {\tau^* \tstep \tau^{*\prime}
                \\ v_i \val ~ \forall v_i \in v^*}
            {v^*~ \tau^*~ e^*~ \tstep v^*~ \tau^{*\prime}~ e^*}
        \and \Rule{STEP - Mixed}
            {e^* \step e^{*\prime}
                \\ \tau_i \prim ~ \forall~ \tau_i \in \tau^*}
            {\tau^*~ e^* ~ \tau_2^*  \step \tau^* ~ e^{*\prime} ~ \tau_1}
    \end{mathpar}
}

\subsection{Type Identifiers}
Type identifiers use the same store as used for values, however their identifiers are guaranteed to not conflict as type identifiers start with a capital letter vs lower-case for value identifiers. Because we use the same store the step semantics for closures and scopes continue to work.
{
    \centering
    \def \MathparLineskip{\lineskip=0.43cm}
    \begin{mathpar}
        \Rule{Type-Let}
            {\tau \prim
                \\ \sigma = [ [...], ... [ T_1 \tstep \tau_1 ... T_n \tstep \tau_n] ]
                \\ \sigma' = [ [...], ... [ T_1 \tstep \tau_1 ... T_n \tstep \tau_n, T_{n+1} \tstep \tau] ]}
            {\sigma; \tau ~ \kweid{T} = \tstep \sigma'; \varepsilon}
    
        \and \Rule{MACRO-2}
            {\sigma = [ ..., [x_1 \step v_1 ~ ... ~ x_n \step v_n, 
                ~ T_1 \tstep \tau_1 ~ ... ~ T_n \tstep \tau_n ]]
                \\ \tau_i \val~ \forall~ \tau_i \in \tau^*}
            {\sigma; \kwmacro{\tau^*}{e^*} \step \sigma; \kwmacro{\tau^*}{[v_1/x_1]...[v_n/x_n][\tau_1/T_1]...[\tau_n/T_n] e^*} \val}

        \and \Rule{Type-Id}
            { \kwid{T} \step \tau \in \sigma(-1)}
            {\sigma; \kwid{T} \tstep \sigma; \tau}
    \end{mathpar}
}

\subsection{Tuples}
{
    \centering
    \def \MathparLineskip{\lineskip=0.43cm}
    \begin{mathpar}
        % Tuple type literals evaluation
        \Rule{Tuple Types - 1}
            {\tau^* \tstep \tau^{*\prime}}
            {( \tau^* ) \tstep ( \tau^{*\prime} )}
        \Rule{Tuple Types - 2}
            {\tau_i \prim ~ \forall \tau_i \in \tau^*}
            {(\tau^*) \prim}
        \and
        % unpack operator
        \Rule{Tuple Types - 3}
            {\tau_i \prim ~ \forall~ \tau_i \in \tau^*}
            {\kwunpack{(\tau^*)} \tstep \tau_1 ... \tau_n}
    \end{mathpar}
}

\subsection{Others}
{
    \centering
    \def \MathparLineskip{\lineskip=0.43cm}
    \begin{mathpar}
        \Rule{Type Equiv}
            {\tau_1 \prim \\ \tau_2 \prim}
            {\tau_1~ \tau_2~ ==~ \tstep~ \kwnumlit{(\delta_{\tau_1 \tau_2})}{\kwInt}}

        % fixed point combinator
        \and \Rule{Fixed Point}
            {\kwmacro{\tau^*~ \tau_1}{e^*} \val \\ \tau_1 \prim}
            {\kwfix{\kwmacro{\tau^*~ \tau_1}{e^*}}{\tau_1} \val}
        \and \Rule{Call FP}
            {v = \kwfix{\kwmacro{\tau^*~ \tau_1}{e^*}}{\tau_1} \\ v \val}
            {v~ \textbf{@} \step v~ \kwmacro{\tau^*~ \tau_1}{e^*}~ \textbf{@}}
        
        % input types for macros can step
        \and \Rule{Macro Type Step}
            {\tau^* \tstep \tau^{*\prime}}
            {\sigma; \kwmacro{\tau^*}{e^*} \tstep \sigma; \kwmacro{\tau^{*\prime}}{e^*}}
        
        % typeof operator
        \Rule{TYPE-1}{v \val \\ \etyped{v}{\tau}}{\kwType{v} \tstep \tau} 
    \end{mathpar}
}

\section{Typing}
Note that we're using a somewhat weird notation for a stack machine (normally there's arrows representing stack transformation). This aligns with how we defined our syntax.

\subsection{Step Judgement}
{
    \centering
    \begin{mathpar}
    \Rule{T-0}
        {\typed{\ctx}{e}{\tau} \\ \tau \tstep \tau'}
        {\typed{\ctx}{e}{\tau'}}
    \end{mathpar}
}

\subsection{Math and Logic}
{
    \centering
    \def \MathparLineskip {\lineskip=0.43cm}
    \begin{mathpar}
        \Rule{T-1}{\strut}{\typed{\ctx}{\kwnumlit{n}{\kwInt}}{\kwInt}}
        \and \Rule{T-2}{\strut}{\typed{\ctx}{\kwnumlit{n}{\kwLong}}{\kwLong}}
        \and \Rule{T-3}{\strut}{\typed{\ctx}{\kwnumlit{n}{\kwFloat}}{\kwFloat}}
        \and \Rule{T-4}{\strut}{\typed{\ctx}{\kwnumlit{n}{\kwDouble}}{\kwDouble}}
        \and \Rule{T-5}
            {\typed{\ctx}{e_1}{\tau} 
                \\ \typed{\ctx}{e_2}{\tau} 
                \\ \tau \in \{\kwInt, \kwLong, \kwFloat, \kwDouble\}}
            {\typed{\ctx}{e_1~ e_2~ +}{\tau}}
        \and \Rule{T-6}
            {\typed{\ctx}{e_1}{\tau} 
                \\ \typed{\ctx}{e_2}{\tau} 
                \\ \tau \in \{\kwInt, \kwLong, \kwFloat, \kwDouble\}}
            {\typed{\ctx}{e_1~ e_2~ \times}{\tau}}
        \and \Rule{T-7}
            {\typed{\ctx}{e_1}{\kwInt}
                \\ \typed{\ctx}{e_2}{\tau}
                \\ \typed{\ctx}{e_3}{\tau}}
            {\typed{\ctx}{\kwtern{e_1}{e_2}{e_3}}{\tau}}
        \and \Rule{T-8}
            {\typed{\ctx}{e_1}{\tau}
                \\ \typed{\ctx}{e_2}{\tau}
                \\ \tau \in \{ \kwInt, \kwLong, \kwFloat, \kwDouble \}}
            {\typed{\ctx}{e_1~ e_2~ ==~}{\kwInt}}
        \and \Rule{T-9}
            {\tau_1 \prim
                \\ \tau_2 \prim}
            {\typed{\ctx}{\tau_1~ \tau_2~ ==~}{\kwInt}}
    \end{mathpar}
}

\subsection{Tuples}
{
    \centering
    \def \MathparLineskip {\lineskip=0.43cm}
    \begin{mathpar}
        \Rule{Empty Tuple}{\strut}{\typed{\ctx}{()}{\kwUnit}}
        \and \Rule{Tuple Type}
            {\tau^* = \{ \tau_i ~\text{such that}~ \typed{\ctx}{e_i}{\tau_i}~ \forall ~ e_i \in e^* \} }
            {\typed{\ctx}{(e^*)}{(\tau^*)}}
        \and \Rule{Unpack}
            {\typed{\ctx}{(e^*)}{(\tau^*)}}
            {\typed{\ctx}{\kwunpack{(e^*)}}{\tau^*}}
    \end{mathpar}
}

\subsection{Macros}
This is why we needed the step judgement
{
    \centering
    \def \MathparLineskip {\lineskip=0.43cm}
    \begin{mathpar}
        % Move this to type rules   
        \Rule{Macro}
            {\tau^* = \tau_1 ~...~ \tau_n \\
             v^* = \etyped{v_1}{\tau_1} ~...~ \etyped{v_n}{\tau_n} \\
             m = \kwmacro{\tau^*}{e^*} \\
             m \val }
            {\typed{\ctx}{\kwmacro{\tau^*}{e^*}}{\kwArrow{(\tau^*)}{\kwType{(v^*~ m~ \textbf{@})}}}}
        
        \and \Rule{Call}
            {\typed{\ctx}{e_1}{\kwArrow{\tau^*}{\tau^{*\prime}}}
                \\ \typed{\ctx}{e^*}{\tau^*}}
            {\typed{\ctx}{e^*~ e_1~ \textbf{@}}{\tau^{*\prime}}}
        
        \and \Rule{Identifier}
            {\ctx(\kwid{x}) = \tau}
            {\typed{\ctx}{\kwid{x}}{\tau}}
            
        \and \Rule{Let}
            {\typed{\ctx}{e}{\tau}
                \\ \ctx(\kwid{x}) = \tau}
            {\typed{\ctx}{e~ \kwid{x} =}{\varepsilon}}
            
        \and \Rule{Fix}
            {\tau_1 \prim
                \\ \tau_1 = \kwArrow{(\tau^*_3)}{(\tau^*_4)}
                \\ \typed{\ctx}{e}{\kwArrow{(\tau^*_3 ~ \tau_1)}{(\tau^*_4)}}}
            {\typed{\ctx}{\kwfix{e}{\tau_1}}{\tau_1}}
            
        \and \Rule{end_scope type}{\strut}{\typed{\ctx}{\kw{end\_scope}}{\varepsilon}}
    \end{mathpar}
}

\section{Proofs}
\subsection{Theorem - Progress}
If $\etyped{e^*}{\tau^*}$ then either $e^*\step e^{*\prime}$ or $e_i \val~ \forall~ e_i \in e^*$.
\begin{proof}
    By induction on the derivation of $\etyped{e^*}{\tau^*}$.
    \begin{itemize}
        \item (T-\{1,2,3,4\})
            Then $e^* = \kwnumlit{n}{\tau}$, where $\tau \in \{\kwInt, \kwLong, \kwFloat, \kwDouble\}$.
            By (V-1), $\kwnumlit{n}{\tau} \val$, so $e^* \val$.
        
        \item (T-5)
            Then $e^* = e_1~ e_2~ +$ and $\etyped{e_1}{\tau}$ and $\etyped{e_2}{\tau}$ for some $\tau \in \{\kwInt, \kwLong, \kwFloat, \kwDouble\}$.
            
            By induction, $e_1 \step e_1'$ or $e_1 \val$.
            If $e_1 \step e_1'$, then by \Rulename{STEP}, $e^* \step e_1'~ e_2~ +$.
            
            If $e_1 \val$, then by induction, $e_2 \step e_2'$ or $e_2 \val$.
            If $e_1 \val$ and $e_2 \step e_2'$, then by \Rulename{STEP}, $e^* \step e_1~ e_2'~ +$.
            
            If $e_1 \val$ and $e_2 \val$, then by CF, $e_1 = \kwnumlit{n_1}{\tau}, e_2 = \kwnumlit{n_2}{\tau}$, and by \Rulename{ADD}, $e^* \step \kwnumlit{n_1 + n_2}{\tau}$.
        
        \item (T-6)
            $[\times / +][\Rulename{MUL} / \Rulename{ADD}]$ (T-5)
        
        \item (T-7)
            Then $e^* = \kwtern{e_1}{e_2}{e_3}$ and $\etyped{e_1}{\kwInt}$. %and $\etyped{e_2}{\tau}$ and $\etyped{e_3}{\tau}$ for some $\tau$.
            
            By induction, $e_1 \step e_1'$ or $e_1 \val$.
            If $e_1 \step e_1'$, then by \Rulename{STEP}, $e^* \step \kwtern{e_1'}{e_2}{e_3}$.
            
            If $e_1 \val$, then by induction, $e_2 \step e_2'$ or $e_2 \val$.
            If $e_1 \val$ and $e_2 \step e_2'$, then by \Rulename{STEP}, $e^* \step \kwtern{e_1}{e_2'}{e_3}$.
            
            If $e_1 \val$ and $e_2 \val$, then by induction, $e_3 \step e_3'$ or $e_3 \val$.
            If $e_1 \val$ and $e_2 \val$ and $e_3 \step e_3'$, then by \Rulename{STEP}, $e \step \kwtern{e_1}{e_2}{e_3'}$.
            
            If $e_1 \val$ and $e_2 \val$ and $e_3 \val$, then by CF, $e_1 = \kwnumlit{n}{\kwInt}$.
            
            If $n = 0$, then by \Rulename{TERN-1}, $e^* \step e_3$.
            Otherwise, $n \neq 0$, so by \Rulename{TERN-2}, $e^* \step e_2$.
        
        \item \Rulename{Empty Tuple}
            Then $e^* = ()$. By \Rulename{TUPLES-2}, $() \val$.
        
        \item \Rulename{Tuple Type}
            Then $e^* = (e^*_t) = (e_1~ e_2~ ...~ e_n)$.
            
            By induction, $\forall e_i \in e^*_t$, $e_i \val$ or $e_i \step e_i'$.
            
            If all elements are values, then $(e^*_t) \val$ by \Rulename{TUPLES-2}.
            
            Otherwise, one or more elements can step, including a leftmost steppable element $e_j \step e_j'$.
            Then, by \Rulename{STEP}, $e^*_t \step [e_j' / e_j] e^*_t$, so by \Rulename{Tuples-1}, $e^* \step ([e_j' / e_j] e^*_t)$.
            
        \item \Rulename{Unpack}
            Then $e^* = \kwunpack{(e^*_t)}$.
            By induction, either $(e^*_t) \step (e^{*'}_t)$ or $(e^*_t) \val$.
            
            If $(e^{*'}_t) \step (e^{*'}_t)$, then by \Rulename{STEP}, $\kwunpack{(e^*_t)} \step \kwunpack{(e^{*'}_t)}$.
            
            If $(e^*_t) \val$, then by \Rulename{TUPLES-3}, $\kwunpack{(e^*_t)} \step e^*_t$.
        
        \item \Rulename{Macro}
            Then $e^* = m = \kwmacro{\tau^*}{e^*_t}$. $m \val$ by the premise.
        
        \item \Rulename{Call}
            Then $e^* = e^*_x~ e_f~ \textbf{@}$. By induction, either $e_i \val~ \forall~ e_i \in e^*_x$ or $e^*_x \step e^{*'}_x$.
            
            If $e^*_x \step e^{*'}_x$, then by \Rulename{STEP}, $e^* \step e^{*'}_x~ e_f~ \textbf{@}$.
            
            Otherwise, $e_i \val~ \forall~ e_i \in e^*_x$ and, by induction, $e_f \val$ or $e_f \step e_f'$.
            
            If $e_f \step e_f'$, then by \Rulename{STEP}, $e^* \step e^*_x~ e_f'~ \textbf{@}$.
            
            Otherwise, $e_f \val$. To handwave a bit, by inversion on \Rulename{Macro}, $e_f$ is a macro with a body $e^*_b$, and by \Rulename{CALL-1}, $e^* \step e^*_b ~ \textbf{end_scope}$.
        
        \item \Rulename{Identifier}
            Then $e^* = \texttt{x}$.
            By, uh, the other \Rulename{Identifier}, $e^*$ steps to a value in the store.
            
        \item \Rulename{Let}
            Then $e^* = e ~ \texttt{x} =$.
            By induction, $e \val$ or $e \step e'$.
            If $e \step e'$, then by \Rulename{STEP}, $e^* \step e' ~ \texttt{x} =$.
            If $e \val$, then by the other \Rulename{LET}, $\sigma;e^* \step \sigma';\varepsilon$, where $\sigma'$ is, as described in the rule, $\sigma$ with $x \step e$ added to its ``topmost'' scope.
        
        \item \Rulename{Fix}
            Then $e^* = \kwfix{e}{\tau_1}$.
            By induction, $e \val$ or $e \step e'$.
            If $e \step e'$, then by \Rulename{STEP}, $e^* \step \kwfix{e'}{\tau_1}$.
            If $e \val$, then I think I'm missing something here, but by \Rulename{Fixed Point}, $e^* \val$.
    \end{itemize}
\end{proof}

\subsection{Theorem - Preservation}
If $\typed{\ctx}{e^*}{\tau^*}$ and $e^* \step e^{*\prime}$ then $\typed{\ctx}{e^{*\prime}}{\tau^{*\prime}}$ where $\tau^* \tstep^* \tau^{*\prime}$.

\begin{proof}
By induction on the derivation of $e^* \step e^{*\prime}$.
\begin{itemize}
    \item \Rulename{STEP}
        Then $e^* = v^* e_1 ... e_n$ and $e^ \step v^* e_1' ... e_n$ where $\etyped{e_1}{\tau}$ and $\etyped{e_1'}{\tau'}$.
        By induction, $\tau \tstep^* \tau'$, so by \Rulename{TSTEP}, $\tau^* \tstep^* [\tau' / \tau]\tau^*$.
    
    \item \Rulename{TUPLES-1}
        Then $e^* = (e_{elem}^*)$ and $e^* \step (e_{elem}^{*\prime})$ and $\tau^* = (\tau_{elem}^*)$.
        By induction, $\etyped{e_{elem}^{*\prime}}{\tau_{elem}^{*\prime}}$ where $\tau_{elem}^* \tstep^* \tau_{elem}^{*\prime}$. By \Rulename{Tuple Type}, $\etyped{(e_{elem}^{*\prime})}{(\tau_{elem}^{*'})}$, and by \Rulename{Tuple Types - 1}, $(\tau_{elem}^*) \tstep (\tau_{elem}^{*'})$.
        
    \item \Rulename{LET}
        Then $e^* = v ~ \texttt{\$x} ~ =$. By the other \Rulename{Let}, $\etyped{e^*}{\varepsilon}$, so $\tau^* = \varepsilon$. $e^* \step \varepsilon$, so $\tau^{*\prime} = \varepsilon$, so $\tau^* = \tau^{*\prime}$.

    \item \Rulename{Identifier}
        Then $e^* = \texttt{x}$, where $\texttt{x} \step v$ is in scope. By the other \Rulename{Identifier}, the type of an identifier expression is the same as the type of the value in the store ($\etyped{v}{\tau}$), so $\tau^* = \tau^{*\prime} = \tau$.
    
    \item \Rulename{CALL-1}
        Then $e^* = $.
        % I think we need to modify (CALL-1) to require the values? Revisit.
    
    \item \Rulename{CALL-2}
        % do we need a type rule for end_scope?
    
    \item \Rulename{TUPLES-3}
        Then $e^* = \kwunpack{(v^*)}$, where $\etyped{v^*}{\tau_{elem}^*}$.
        By \Rulename{Unpack}, $\tau^* = \tau_{elem}^*$. $e^* \step v^*$, so $\tau^{*\prime} = \tau^* = \tau_{elem}^*$.
    
    \item \Rulename{ADD} \footnote{For these three rules, terms of the form $v_n$ are better expressed as numeric literals.}
        Then $e^* = v_1~ v_2~ +$ and $e^* \step v_3$, where $\etyped{v_1}{\tau}$ and $\etyped{v_2}{\tau}$ for some $\tau \in \{\kwInt, \kwLong, \kwFloat, \kwDouble\}$.
        By \Rulename{T-5}, $\etyped{v_1~ v_2~ +}{\tau}$, and by the appropriate choice of \Rulename{T-1}, \Rulename{T-2}, \Rulename{T-3}, or \Rulename{T-4}, $\etyped{v_3}{\tau}$., so $\tau^* = \tau^{*\prime} = \tau$.
    
    \item \Rulename{MUL}
        Omitted for brevity on the grounds of being mechanically identical to the above case.
    
    \item \Rulename{EQUIV}
        Then $e^* = v_1~ v_2~ ==$ where $\etyped{v_1}{\tau}$ and $\etyped{v_2}{\tau}$ for some $\tau \in \{\kwInt, \kwLong, \kwFloat, \kwDouble\}$.
        By \Rulename{T-8}, $\tau^* = \kwInt$.
        $e^* \step \kwnumlit{n}{\kwInt}$, and by \Rulename{T-1}, $\etyped{\kwnumlit{n}{\kwInt}}{\kwInt}$, so $\tau^{*\prime} = \tau^* = \kwInt$.
    
    \item \Rulename{TERN-1}, \Rulename{TERN-2}
        Then $e^* = \kwtern{\kwnumlit{n}{\kwInt}}{v_1}{v_2}$ and $\etyped{v_1}{\tau}$ and $\etyped{v_2}{\tau}$ for some $\tau$.
        By \Rulename{T-7}, $\etyped{e^*}{\tau}$, so $\tau^* = \tau$.
        Either $e^* \step v_1$ or $e_* \step v_2$, so in either case, $\tau^{*\prime} = \tau$.
\end{itemize}

\end{proof}

\end{document}
